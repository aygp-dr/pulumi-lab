<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/">

    <title>Syntax &#8212; Hy 1.0.0 manual</title>
    <link rel="stylesheet" type="text/css" href="/hy/doc/v1.0.0/_static/pygments.css">
    <link rel="stylesheet" type="text/css" href="/hy/doc/v1.0.0/_static/nature.css">
    <link rel="stylesheet" type="text/css" href="/hy/doc/v1.0.0/_static/custom.css">
    
    
    
    
    
    <link rel="index" title="Index" href="/hy/doc/v1.0.0/genindex">
    <link rel="search" title="Search" href="/hy/doc/v1.0.0/search">
    <link rel="next" title="Semantics" href="/hy/doc/v1.0.0/semantics">
    <link rel="prev" title="Tutorial" href="/hy/doc/v1.0.0/tutorial"> 
  <link rel="icon" type="image/png" href="/favicon.png"></head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        
        
        
        <li class="right">
          <a href="/hy/doc/v1.0.0/semantics" title="Semantics" accesskey="N">next</a> |</li>
        <li class="right">
          <a href="/hy/doc/v1.0.0/tutorial" title="Tutorial" accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="/hy/doc/v1.0.0/">Hy 1.0.0 (Afternoon Review) manual</a></li>
         
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="syntax">
<span id="id1"></span><h1>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading">&#182;</a></h1>
<p>This chapter describes how Hy source code is understood at the level of text,
as well as the abstract syntax objects that the reader (a.k.a. the parser)
turns text into, as when invoked with <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.read" title="hy.read"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.read</span></code></a>. The basic units of
syntax at the textual level are called <strong>forms</strong>, and the basic objects
representing forms are called <strong>models</strong>.</p>
<p>Following Python, Hy is in general case-sensitive. For example, <code class="docutils literal notranslate"><span class="pre">foo</span></code> and
<code class="docutils literal notranslate"><span class="pre">FOO</span></code> are different symbols, and the Python-level variables they refer to are
also different.</p>
<nav class="contents local" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#an-introduction-to-models" id="id12">An introduction to models</a></p></li>
<li><p><a class="reference internal" href="#non-form-syntactic-elements" id="id13">Non-form syntactic elements</a></p>
<ul>
<li><p><a class="reference internal" href="#shebang" id="id14">Shebang</a></p></li>
<li><p><a class="reference internal" href="#whitespace" id="id15">Whitespace</a></p></li>
<li><p><a class="reference internal" href="#comments" id="id16">Comments</a></p></li>
<li><p><a class="reference internal" href="#discard-prefix" id="id17">Discard prefix</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#identifiers" id="id18">Identifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#numeric-literals" id="id19">Numeric literals</a></p></li>
<li><p><a class="reference internal" href="#keywords" id="id20">Keywords</a></p></li>
<li><p><a class="reference internal" href="#dotted-identifiers" id="id21">Dotted identifiers</a></p></li>
<li><p><a class="reference internal" href="#symbols" id="id22">Symbols</a></p></li>
<li><p><a class="reference internal" href="#mangling" id="id23">Mangling</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#hystring" id="id24">String literals</a></p>
<ul>
<li><p><a class="reference internal" href="#bracket-strings" id="id25">Bracket strings</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#sequential-forms" id="id26">Sequential forms</a></p>
<ul>
<li><p><a class="reference internal" href="#expressions" id="id27">Expressions</a></p></li>
<li><p><a class="reference internal" href="#list-tuple-and-set-literals" id="id28">List, tuple, and set literals</a></p></li>
<li><p><a class="reference internal" href="#dictionary-literals" id="id29">Dictionary literals</a></p></li>
<li><p><a class="reference internal" href="#format-strings" id="id30">Format strings</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#additional-sugar" id="id31">Additional sugar</a></p></li>
<li><p><a class="reference internal" href="#reader-macros" id="id32">Reader macros</a></p></li>
</ul>
</nav>
<section id="an-introduction-to-models">
<span id="models"></span><h2><a class="toc-backref" href="#id12" role="doc-backlink">An introduction to models</a><a class="headerlink" href="#an-introduction-to-models" title="Permalink to this heading">&#182;</a></h2>
<p>Reading a Hy program produces a nested structure of model objects. Models can
be very similar to the kind of value they represent (such as <a class="reference internal" href="#hy.models.Integer" title="hy.models.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>, which is a subclass of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) or they can be
somewhat different (such as <a class="reference internal" href="#hy.models.Set" title="hy.models.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a>, which is ordered,
unlike actual <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#set" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>s). All models inherit from <a class="reference internal" href="#hy.models.Object" title="hy.models.Object"><code class="xref py py-class docutils literal notranslate"><span class="pre">Object</span></code></a>, which stores textual position information, so tracebacks
can point to the right place in the code. The compiler takes whatever models
are left over after parsing and macro-expansion and translates them into Python
<a class="reference external" href="https://docs.python.org/3/library/ast.html#module-ast" title="(in Python v3.12)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> nodes (e.g., <a class="reference internal" href="#hy.models.Integer" title="hy.models.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> becomes
<a class="reference external" href="https://docs.python.org/3/library/ast.html#ast.Constant" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Constant</span></code></a>), which can then be evaluated or rendered as Python code.
Macros (that is, regular macros, as opposed to reader macros) operate on the
model level, taking some models as arguments and returning more models for
compilation or further macro-expansion; they're free to do quite different
things with a given model than the compiler does, if it pleases them to, like
using an <a class="reference internal" href="#hy.models.Integer" title="hy.models.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> to construct a <a class="reference internal" href="#hy.models.Symbol" title="hy.models.Symbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code></a>.</p>
<p>In general, a model doesn't count as equal to the value it represents. For
example, <code class="docutils literal notranslate"><span class="pre">(=</span> <span class="pre">(hy.models.String</span> <span class="pre">"foo")</span> <span class="pre">"foo")</span></code> returns <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a>. But you
can promote a value to its corresponding model with <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.as-model" title="hy.as-model"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.as-model</span></code></a>, or
you can demote a model with the usual Python constructors like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, or you can evaluate a model as Hy code with
<a class="reference internal" href="/hy/doc/v1.0.0/api#hy.eval" title="hy.eval"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.eval</span></code></a>.</p>
<p>Models can be created with the constructors, with the <a class="reference internal" href="/hy/doc/v1.0.0/api#quote" title="quote"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">quote</span></code></a> or
<a class="reference internal" href="/hy/doc/v1.0.0/api#quasiquote" title="quasiquote"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">quasiquote</span></code></a> macros, or with <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.as-model" title="hy.as-model"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.as-model</span></code></a>. Explicit creation
is often not necessary, because the compiler will automatically promote (via
<a class="reference internal" href="/hy/doc/v1.0.0/api#hy.as-model" title="hy.as-model"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.as-model</span></code></a>) any object it's trying to evaluate.</p>
<p>Note that when you want plain old data structures and don't intend to produce
runnable Hy source code, you'll usually be better off using Python's basic data
structures (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, etc.) than models.
Yes, "homoiconicity" is a fun word, but a Hy <a class="reference internal" href="#hy.models.List" title="hy.models.List"><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code></a>
won't provide any advantage over a Python <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> when you're managing a
list of email addresses or something.</p>
<p>The default representation of models (via <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.repr" title="hy.repr"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.repr</span></code></a>) uses quoting for
readability, so <code class="docutils literal notranslate"><span class="pre">(hy.models.Integer</span> <span class="pre">5)</span></code> is represented as <code class="docutils literal notranslate"><span class="pre">'5</span></code>. Python
representations (via <a class="reference external" href="https://docs.python.org/3/library/functions.html#repr" title="(in Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>) use the constructors, and by default are
pretty-printed; you can disable this globally by setting <code class="docutils literal notranslate"><span class="pre">hy.models.PRETTY</span></code>
to <code class="docutils literal notranslate"><span class="pre">False</span></code>, or temporarily with the context manager <code class="docutils literal notranslate"><span class="pre">hy.models.pretty</span></code>.</p>
<span class="target" id="hyobject"></span><dl class="py class">
<dt class="sig sig-object py" id="hy.models.Object">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Object</span></span><a class="headerlink" href="#hy.models.Object" title="Permalink to this definition">&#182;</a></dt>
<dd><p>An abstract base class for Hy models, which represent forms.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Lazy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Lazy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gen</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Lazy" title="Permalink to this definition">&#182;</a></dt>
<dd><p>The output of <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.read-many" title="hy.read-many"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.read-many</span></code></a>. It represents a sequence of forms, and can be
treated as an iterator. Reading each form lazily, only after evaluating the previous
form, is necessary to handle reader macros correctly; see <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.read-many" title="hy.read-many"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.read-many</span></code></a>.</p>
</dd></dl>

</section>
<section id="non-form-syntactic-elements">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Non-form syntactic elements</a><a class="headerlink" href="#non-form-syntactic-elements" title="Permalink to this heading">&#182;</a></h2>
<section id="shebang">
<span id="id2"></span><h3><a class="toc-backref" href="#id14" role="doc-backlink">Shebang</a><a class="headerlink" href="#shebang" title="Permalink to this heading">&#182;</a></h3>
<p>If a Hy program begins with <code class="docutils literal notranslate"><span class="pre">#!</span></code>, Hy assumes the first line is a <a class="reference external" href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang
line</a> and ignores it. It's up
to your OS to do something more interesting with it.</p>
<p>Shebangs aren't real Hy syntax, so <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.read-many" title="hy.read-many"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.read-many</span></code></a> only allows them
if its option <code class="docutils literal notranslate"><span class="pre">skip_shebang</span></code> is enabled.</p>
</section>
<section id="whitespace">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Whitespace</a><a class="headerlink" href="#whitespace" title="Permalink to this heading">&#182;</a></h3>
<p>Hy has lax whitespace rules less similar to Python's than to those of most
other programming languages. Whitespace can separate forms (e.g., <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">b</span></code> is
two forms whereas <code class="docutils literal notranslate"><span class="pre">ab</span></code> is one) and it can occur inside some forms (like
string literals), but it's otherwise ignored by the reader, producing no
models.</p>
<p>The reader only grants this special treatment to the ASCII whitespace
characters, namely U+0009 (horizontal tab), U+000A (line feed), U+000B
(vertical tab), U+000C (form feed), U+000D (carriage return), and U+0020
(space). Non-ASCII whitespace characters, such as U+2009 (THIN SPACE), are
treated as any other character. So yes, you can have exotic whitespace
characters in variable names, although this is only especially useful for
obfuscated code contests.</p>
</section>
<section id="comments">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Comments</a><a class="headerlink" href="#comments" title="Permalink to this heading">&#182;</a></h3>
<p>Comments begin with a semicolon (<code class="docutils literal notranslate"><span class="pre">;</span></code>) and continue through the end of the
line.</p>
<p>There are no multi-line comments in the style of C's <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">&#8230;</span> <span class="pre">*/</span></code>, but you can
use the <a class="reference internal" href="#discard-prefix"><span class="std std-ref">discard prefix</span></a> or <a class="reference internal" href="#string-literals"><span class="std std-ref">string literals</span></a> for similar purposes.</p>
</section>
<section id="discard-prefix">
<span id="id3"></span><h3><a class="toc-backref" href="#id17" role="doc-backlink">Discard prefix</a><a class="headerlink" href="#discard-prefix" title="Permalink to this heading">&#182;</a></h3>
<p>Like Clojure, Hy supports the Extensible Data Notation discard prefix <code class="docutils literal notranslate"><span class="pre">#_</span></code>,
which is kind of like a structure-aware comment. When the reader encounters
<code class="docutils literal notranslate"><span class="pre">#_</span></code>, it reads and then discards the following form. Thus <code class="docutils literal notranslate"><span class="pre">#_</span></code> is like
<code class="docutils literal notranslate"><span class="pre">;</span></code> except that reader macros still get executed, and normal parsing resumes
after the next form ends rather than at the start of the next line: <code class="docutils literal notranslate"><span class="pre">[dilly</span> <span class="pre">#_</span>
<span class="pre">and</span> <span class="pre">krunk]</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">[dilly</span> <span class="pre">krunk]</span></code>, whereas <code class="docutils literal notranslate"><span class="pre">[dilly</span> <span class="pre">;</span> <span class="pre">and</span>
<span class="pre">krunk]</span></code> is equivalent to just <code class="docutils literal notranslate"><span class="pre">[dilly</span></code>. Comments indicated by <code class="docutils literal notranslate"><span class="pre">;</span></code> can be
nested within forms discarded by <code class="docutils literal notranslate"><span class="pre">#_</span></code>, but <code class="docutils literal notranslate"><span class="pre">#_</span></code> has no special meaning
within a comment indicated by <code class="docutils literal notranslate"><span class="pre">;</span></code>.</p>
</section>
</section>
<section id="identifiers">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Identifiers</a><a class="headerlink" href="#identifiers" title="Permalink to this heading">&#182;</a></h2>
<p>Identifiers are a broad class of syntax in Hy, comprising not only variable
names, but any nonempty sequence of characters that aren't ASCII whitespace nor
one of the following: <code class="docutils literal notranslate"><span class="pre">()[]{};"'`~</span></code>. The reader will attempt to read an
identifier as each of the following types, in the given order:</p>
<ol class="arabic simple">
<li><p>a <a class="reference internal" href="#numeric-literals"><span class="std std-ref">numeric literal</span></a></p></li>
<li><p>a <a class="reference internal" href="#keywords"><span class="std std-ref">keyword</span></a></p></li>
<li><p>a <a class="reference internal" href="#dotted-identifiers"><span class="std std-ref">dotted identifier</span></a></p></li>
<li><p>a <a class="reference internal" href="#symbols"><span class="std std-ref">symbol</span></a></p></li>
</ol>
<section id="numeric-literals">
<span id="id4"></span><h3><a class="toc-backref" href="#id19" role="doc-backlink">Numeric literals</a><a class="headerlink" href="#numeric-literals" title="Permalink to this heading">&#182;</a></h3>
<p>All of <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#numbers" title="(in Python v3.12)"><span class="xref std std-ref">Python's syntax for numeric literals</span></a> is supported in
Hy, resulting in an <a class="reference internal" href="#hy.models.Integer" title="hy.models.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>, <a class="reference internal" href="#hy.models.Float" title="hy.models.Float"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float</span></code></a>, or <a class="reference internal" href="#hy.models.Complex" title="hy.models.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Complex</span></code></a>. Hy also provides a
few extensions:</p>
<ul class="simple">
<li><p>Commas (<code class="docutils literal notranslate"><span class="pre">,</span></code>) can be used like underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>) to separate digits
without changing the result. Thus, <code class="docutils literal notranslate"><span class="pre">10_000_000_000</span></code> may also be written
<code class="docutils literal notranslate"><span class="pre">10,000,000,000</span></code>. Hy is also more permissive about the placement of
separators than Python: several may be in a row, and they may be after all
digits, after <code class="docutils literal notranslate"><span class="pre">.</span></code>, <code class="docutils literal notranslate"><span class="pre">e</span></code>, or <code class="docutils literal notranslate"><span class="pre">j</span></code>, or even inside a radix prefix. Separators
before the first digit are still forbidden because e.g. <code class="docutils literal notranslate"><span class="pre">_1</span></code> is a legal
Python variable name, so it's a symbol in Hy rather than an integer.</p></li>
<li><p>Integers can begin with leading zeroes, even without a radix prefix like
<code class="docutils literal notranslate"><span class="pre">0x</span></code>. Leading zeroes don't automatically cause the literal to be
interpreted in octal like they do in C. For octal, use the prefix <code class="docutils literal notranslate"><span class="pre">0o</span></code>, as
in Python.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NaN</span></code>, <code class="docutils literal notranslate"><span class="pre">Inf</span></code>, and <code class="docutils literal notranslate"><span class="pre">-Inf</span></code> are understood as literals. Each produces a
<a class="reference internal" href="#hy.models.Float" title="hy.models.Float"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float</span></code></a>. These are case-sensitive, unlike other uses
of letters in numeric literals (<code class="docutils literal notranslate"><span class="pre">1E2</span></code>, <code class="docutils literal notranslate"><span class="pre">0XFF</span></code>, <code class="docutils literal notranslate"><span class="pre">5J</span></code>, etc.).</p></li>
<li><p>Hy allows complex literals as understood by the constructor for
<a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>, such as <code class="docutils literal notranslate"><span class="pre">5+4j</span></code>. (This is also legal Python, but Hy reads
it as a single <a class="reference internal" href="#hy.models.Complex" title="hy.models.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Complex</span></code></a>, and doesn't otherwise
support infix addition or subtraction, whereas Python parses it as an
addition expression.)</p></li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Integer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Integer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Integer" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal integer (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Float">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Float" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal floating-point real number (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Complex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Complex" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal floating-point complex number (<a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>).</p>
</dd></dl>

</section>
<section id="keywords">
<span id="id5"></span><h3><a class="toc-backref" href="#id20" role="doc-backlink">Keywords</a><a class="headerlink" href="#keywords" title="Permalink to this heading">&#182;</a></h3>
<p>An identifier starting with a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>), such as <code class="docutils literal notranslate"><span class="pre">:foo</span></code>, is a
<a class="reference internal" href="#hy.models.Keyword" title="hy.models.Keyword"><code class="xref py py-class docutils literal notranslate"><span class="pre">Keyword</span></code></a>.</p>
<p>Literal keywords are most often used for their special treatment in
<a class="reference internal" href="#expressions"><span class="std std-ref">expressions</span></a> that aren't macro calls: they set
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-keyword-argument" title="(in Python v3.12)"><span class="xref std std-term">keyword arguments</span></a>, rather than being passed in
as values. For example, <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">:foo</span> <span class="pre">3)</span></code> calls the function <code class="docutils literal notranslate"><span class="pre">f</span></code> with the
parameter <code class="docutils literal notranslate"><span class="pre">foo</span></code> set to <code class="docutils literal notranslate"><span class="pre">3</span></code>. The keyword is also <a class="reference internal" href="#mangling"><span class="std std-ref">mangled</span></a>
at compile-time. To prevent a literal keyword from being treated specially in
an expression, you can <a class="reference internal" href="/hy/doc/v1.0.0/api#quote" title="quote"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">quote</span></code></a> the keyword, or you can use it as the
value for another keyword argument, as in <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">:foo</span> <span class="pre">:bar)</span></code>.</p>
<p>Otherwise, keywords are simple model objects that evaluate to themselves. Users
of other Lisps should note that it's often a better idea to use a string than a
keyword, because the rest of Python uses strings for cases in which other Lisps
would use keywords. In particular, strings are typically more appropriate than
keywords as the keys of a dictionary. Notice that <code class="docutils literal notranslate"><span class="pre">(dict</span> <span class="pre">:a</span> <span class="pre">1</span> <span class="pre">:b</span> <span class="pre">2)</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">{"a"</span> <span class="pre">1</span> <span class="pre">"b"</span> <span class="pre">2}</span></code>, which is different from <code class="docutils literal notranslate"><span class="pre">{:a</span> <span class="pre">1</span> <span class="pre">:b</span> <span class="pre">2}</span></code> (see
<a class="reference internal" href="#dict-literals"><span class="std std-ref">Dictionary literals</span></a>).</p>
<p>The empty keyword <code class="docutils literal notranslate"><span class="pre">:</span></code> is syntactically legal, but you can't compile a
function call with an empty keyword argument because of Python limitations.
Thus <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">:</span> <span class="pre">3)</span></code> must be rewritten to use runtime unpacking, as in <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">#**</span>
<span class="pre">{""</span> <span class="pre">3})</span></code>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Keyword">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Keyword</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Keyword" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a keyword, such as <code class="docutils literal notranslate"><span class="pre">:foo</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> -- The string content of the keyword, not including the leading <code class="docutils literal notranslate"><span class="pre">:</span></code>. No
mangling is performed.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="hy.models.Keyword.__bool__">
<span class="sig-name descname"><span class="pre">__bool__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Keyword.__bool__" title="Permalink to this definition">&#182;</a></dt>
<dd><p>The empty keyword <code class="docutils literal notranslate"><span class="pre">:</span></code> is false. All others are true.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hy.models.Keyword.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;object</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Keyword.__call__" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Get the element of <code class="docutils literal notranslate"><span class="pre">data</span></code> named <code class="docutils literal notranslate"><span class="pre">(hy.mangle</span> <span class="pre">self.name)</span></code>. Thus, <code class="docutils literal notranslate"><span class="pre">(:foo</span>
<span class="pre">bar)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(get</span> <span class="pre">bar</span> <span class="pre">"foo")</span></code> (which is different from
<code class="docutils literal notranslate"><span class="pre">(get</span> <span class="pre">bar</span> <span class="pre">:foo)</span></code>; dictionary keys are typically strings, not
<a class="reference internal" href="#hy.models.Keyword" title="hy.models.Keyword"><code class="xref py py-class docutils literal notranslate"><span class="pre">hy.models.Keyword</span></code></a> objects).</p>
<p>The optional second parameter is a default value; if provided, any
<a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyError</span></code></a> from <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.pyops.get" title="hy.pyops.get"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">get</span></code></a> will be caught,
and the default returned instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hy.models.Keyword.__lt__">
<span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Keyword.__lt__" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Keywords behave like strings under comparison operators, but are incomparable
to actual <code class="docutils literal notranslate"><span class="pre">str</span></code> objects.</p>
</dd></dl>

</dd></dl>

</section>
<section id="dotted-identifiers">
<span id="id6"></span><h3><a class="toc-backref" href="#id21" role="doc-backlink">Dotted identifiers</a><a class="headerlink" href="#dotted-identifiers" title="Permalink to this heading">&#182;</a></h3>
<p>Dotted identifiers are named for their use of the dot character <code class="docutils literal notranslate"><span class="pre">.</span></code>, also
known as a period or full stop. They don't have their own model type because
they're actually syntactic sugar for <a class="reference internal" href="#expressions"><span class="std std-ref">expressions</span></a>. Syntax
like <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(.</span> <span class="pre">foo</span> <span class="pre">bar</span> <span class="pre">baz)</span></code>. The general rule is
that a dotted identifier looks like two or more <a class="reference internal" href="#symbols"><span class="std std-ref">symbols</span></a>
(themselves not containing any dots) separated by single dots. The result is an
expression with the symbol <code class="docutils literal notranslate"><span class="pre">.</span></code> as its first element and the constituent
symbols as the remaining elements.</p>
<p>A dotted identifier may also begin with one or more dots, as in <code class="docutils literal notranslate"><span class="pre">.foo.bar</span></code> or
<code class="docutils literal notranslate"><span class="pre">..foo.bar</span></code>, in which case the resulting expression has the appropriate head
(<code class="docutils literal notranslate"><span class="pre">.</span></code> or <code class="docutils literal notranslate"><span class="pre">..</span></code> or whatever) and the symbol <code class="docutils literal notranslate"><span class="pre">None</span></code> as the following element.
Thus, <code class="docutils literal notranslate"><span class="pre">..foo.bar</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(..</span> <span class="pre">None</span> <span class="pre">foo</span> <span class="pre">bar)</span></code>. In the leading-dot
case, you may also use only one constitutent symbol. Thus, <code class="docutils literal notranslate"><span class="pre">.foo</span></code> is a legal
dotted identifier, and equivalent to <code class="docutils literal notranslate"><span class="pre">(.</span> <span class="pre">None</span> <span class="pre">foo)</span></code>.</p>
<p>See <a class="reference internal" href="/hy/doc/v1.0.0/api#dot"><span class="std std-ref">the dot macro</span></a> for what these expressions typically compile to.
See also the special behavior for <a class="reference internal" href="#expressions"><span class="std std-ref">expressions</span></a> that begin
with a dotted identifier that itself begins with a dot. Note that Hy provides
definitions of <code class="docutils literal notranslate"><span class="pre">.</span></code> and <code class="docutils literal notranslate"><span class="pre">...</span></code> by default, but not <code class="docutils literal notranslate"><span class="pre">..</span></code>, <code class="docutils literal notranslate"><span class="pre">....</span></code>,
<code class="docutils literal notranslate"><span class="pre">.....</span></code>, etc., so <code class="docutils literal notranslate"><span class="pre">..foo.bar</span></code> won't do anything useful by default outside
of macros that treat it specially, like <a class="reference internal" href="/hy/doc/v1.0.0/api#import" title="import"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">import</span></code></a>.</p>
</section>
<section id="symbols">
<span id="id7"></span><h3><a class="toc-backref" href="#id22" role="doc-backlink">Symbols</a><a class="headerlink" href="#symbols" title="Permalink to this heading">&#182;</a></h3>
<p>Symbols are the catch-all category of identifiers. In most contexts, symbols
are compiled to Python variable names, after being <a class="reference internal" href="#mangling"><span class="std std-ref">mangled</span></a>.
You can create symbol objects with the <a class="reference internal" href="/hy/doc/v1.0.0/api#quote" title="quote"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">quote</span></code></a> operator or by calling
the <a class="reference internal" href="#hy.models.Symbol" title="hy.models.Symbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code></a> constructor (thus, <a class="reference internal" href="#hy.models.Symbol" title="hy.models.Symbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code></a> plays a role similar to the <code class="docutils literal notranslate"><span class="pre">intern</span></code> function in other
Lisps). Some example symbols are <code class="docutils literal notranslate"><span class="pre">hello</span></code>, <code class="docutils literal notranslate"><span class="pre">+++</span></code>, <code class="docutils literal notranslate"><span class="pre">3fiddy</span></code>, <code class="docutils literal notranslate"><span class="pre">$40</span></code>,
<code class="docutils literal notranslate"><span class="pre">just&#9992;wrong</span></code>, and <code class="docutils literal notranslate"><span class="pre">&#129425;</span></code>.</p>
<p>Dots are only allowed in a symbol if every character in the symbol is a dot.
Thus, <code class="docutils literal notranslate"><span class="pre">a..b</span></code> and <code class="docutils literal notranslate"><span class="pre">a.</span></code> are neither dotted identifiers nor symbols; they're
syntax errors.</p>
<p>As a special case, the symbol <code class="docutils literal notranslate"><span class="pre">...</span></code> compiles to the <a class="reference external" href="https://docs.python.org/3/library/constants.html#Ellipsis" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> object,
as in Python.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Symbol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Symbol" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a symbol.</p>
<p>Symbol objects behave like strings under operations like <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.pyops.get" title="hy.pyops.get"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">get</span></code></a>,
<a class="reference external" href="https://docs.python.org/3/library/functions.html#len" title="(in Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>, and <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>; in particular, <code class="docutils literal notranslate"><span class="pre">(bool</span> <span class="pre">(hy.models.Symbol</span> <span class="pre">"False"))</span></code> is true. Use <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.eval" title="hy.eval"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.eval</span></code></a> to evaluate a symbol.</p>
</dd></dl>

</section>
<section id="mangling">
<span id="id8"></span><h3><a class="toc-backref" href="#id23" role="doc-backlink">Mangling</a><a class="headerlink" href="#mangling" title="Permalink to this heading">&#182;</a></h3>
<p>Since the rules for Hy symbols and keywords are much more permissive than the rules for
Python identifiers, Hy uses a mangling algorithm to convert its own names to
Python-legal names. The steps are as follows:</p>
<ol class="arabic">
<li><p>Remove any leading underscores. Underscores are typically the ASCII
underscore <code class="docutils literal notranslate"><span class="pre">_</span></code>, but they may also be any Unicode character that normalizes
(according to NFKC) to <code class="docutils literal notranslate"><span class="pre">_</span></code>. Leading underscores have special significance
in Python, and Python normalizes all Unicode before this test, so we'll
process the remainder of the name and then add the leading underscores back
onto the final mangled name.</p></li>
<li><p>Convert ASCII hyphens (<code class="docutils literal notranslate"><span class="pre">-</span></code>) to underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>). Thus, <code class="docutils literal notranslate"><span class="pre">foo-bar</span></code>
becomes <code class="docutils literal notranslate"><span class="pre">foo_bar</span></code>. If the name at this step starts with a hyphen, this
<em>first</em> hyphen is not converted, so that we don't introduce a new leading
underscore into the name. Thus <code class="docutils literal notranslate"><span class="pre">--has-dashes?</span></code> becomes <code class="docutils literal notranslate"><span class="pre">-_has_dashes?</span></code>
at this step.</p></li>
<li><p>If the name still isn't Python-legal, make the following changes. A name
could be Python-illegal because it contains a character that's never legal
in a Python name or it contains a character that's illegal in that position.</p>
<ul class="simple">
<li><p>Prepend <code class="docutils literal notranslate"><span class="pre">hyx_</span></code> to the name.</p></li>
<li><p>Replace each illegal character with <code class="docutils literal notranslate"><span class="pre">XfooX</span></code>, where <code class="docutils literal notranslate"><span class="pre">foo</span></code> is the Unicode
character name in lowercase, with spaces replaced by underscores and
hyphens replaced by <code class="docutils literal notranslate"><span class="pre">H</span></code>. Replace leading hyphens and <code class="docutils literal notranslate"><span class="pre">X</span></code> itself the
same way. If the character doesn't have a name, use <code class="docutils literal notranslate"><span class="pre">U</span></code> followed by its
code point in lowercase hexadecimal.</p></li>
</ul>
<p>Thus, <code class="docutils literal notranslate"><span class="pre">green&#9752;</span></code> becomes <code class="docutils literal notranslate"><span class="pre">hyx_greenXshamrockX</span></code> and
<code class="docutils literal notranslate"><span class="pre">-_has_dashes</span></code> becomes <code class="docutils literal notranslate"><span class="pre">hyx_XhyphenHminusX_has_dashes</span></code>.</p>
</li>
<li><p>Take any leading underscores removed in the first step, transliterate them
to ASCII, and add them back to the mangled name. Thus, <code class="docutils literal notranslate"><span class="pre">__green&#9752;</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">__hyx_greenXshamrockX</span></code>.</p></li>
<li><p>Finally, normalize any leftover non-ASCII characters. The result may still
not be ASCII (e.g., <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is already Python-legal and normalized, so it
passes through the whole mangling procedure unchanged), but it is now
guaranteed that any names are equal as strings if and only if they refer to
the same Python identifier.</p></li>
</ol>
<p>You can invoke the mangler yourself with the function <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.mangle" title="hy.mangle"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.mangle</span></code></a>, and try to undo this (perhaps not quite successfully) with <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.unmangle" title="hy.unmangle"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.unmangle</span></code></a>.</p>
<p>Mangling isn't something you should have to think about often, but you may see
mangled names in error messages, the output of <code class="docutils literal notranslate"><span class="pre">hy2py</span></code>, etc. A catch to be
aware of is that mangling, as well as the inverse "unmangling" operation
offered by <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.unmangle" title="hy.unmangle"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.unmangle</span></code></a>, isn't one-to-one. Two different symbols,
like <code class="docutils literal notranslate"><span class="pre">foo-bar</span></code> and <code class="docutils literal notranslate"><span class="pre">foo_bar</span></code>, can mangle to the same string and hence
compile to the same Python variable.</p>
</section>
</section>
<section id="hystring">
<span id="string-literals"></span><span id="id9"></span><h2><a class="toc-backref" href="#id24" role="doc-backlink">String literals</a><a class="headerlink" href="#hystring" title="Permalink to this heading">&#182;</a></h2>
<p>Hy allows double-quoted strings (e.g., <code class="docutils literal notranslate"><span class="pre">"hello"</span></code>), but not single-quoted
strings like Python. The single-quote character <code class="docutils literal notranslate"><span class="pre">'</span></code> is reserved for
preventing the evaluation of a form, (e.g., <code class="docutils literal notranslate"><span class="pre">'(+</span> <span class="pre">1</span> <span class="pre">1)</span></code>), as in most Lisps
(see <a class="reference internal" href="#more-sugar"><span class="std std-ref">Additional sugar</span></a>). Python's so-called triple-quoted strings (e.g.,
<code class="docutils literal notranslate"><span class="pre">'''hello'''</span></code> and <code class="docutils literal notranslate"><span class="pre">"""hello"""</span></code>) aren't supported, either. However, in Hy, unlike
Python, any string literal can contain newlines; furthermore, Hy has
<a class="reference internal" href="#bracket-strings"><span class="std std-ref">bracket strings</span></a>. For consistency with Python's
triple-quoted strings, all literal newlines in literal strings are read as in
<code class="docutils literal notranslate"><span class="pre">"\n"</span></code> (U+000A, line feed) regardless of the newline style in the actual
code.</p>
<p>String literals support <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#strings" title="(in Python v3.12)"><span class="xref std std-ref">a variety of backslash escapes</span></a>.
Unrecognized escape sequences are a syntax error. To create a "raw string" that
interprets all backslashes literally, prefix the string with <code class="docutils literal notranslate"><span class="pre">r</span></code>, as in
<code class="docutils literal notranslate"><span class="pre">r"slash\not"</span></code>.</p>
<p>By default, all string literals are regarded as sequences of Unicode characters.
The result is the model type <a class="reference internal" href="#hy.models.String" title="hy.models.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>.
You may prefix a string literal with <code class="docutils literal notranslate"><span class="pre">b</span></code> to treat it as a sequence of bytes,
producing <a class="reference internal" href="#hy.models.Bytes" title="hy.models.Bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytes</span></code></a> instead.</p>
<p>Unlike Python, Hy only recognizes string prefixes (<code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">f</span></code>) in
lowercase, and doesn't allow the no-op prefix <code class="docutils literal notranslate"><span class="pre">u</span></code>.</p>
<p><a class="reference internal" href="#syntax-fstrings"><span class="std std-ref">F-strings</span></a> are a string-like compound construct
documented further below.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.String">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">String</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">brackets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.String" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal string (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>brackets</strong> -- The custom delimiter used by the bracket string that parsed to this
object, or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a> if it wasn't a bracket string. The outer square brackets
and <code class="docutils literal notranslate"><span class="pre">#</span></code> aren't included, so the <code class="docutils literal notranslate"><span class="pre">brackets</span></code> attribute of the literal
<code class="docutils literal notranslate"><span class="pre">#[[hello]]</span></code> is the empty string.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Bytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Bytes</span></span><a class="headerlink" href="#hy.models.Bytes" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal bytestring (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>).</p>
</dd></dl>

<section id="bracket-strings">
<span id="id10"></span><h3><a class="toc-backref" href="#id25" role="doc-backlink">Bracket strings</a><a class="headerlink" href="#bracket-strings" title="Permalink to this heading">&#182;</a></h3>
<p>Hy supports an alternative form of string literal called a "bracket string"
similar to Lua's long brackets. Bracket strings have customizable delimiters,
like the here-documents of other languages. A bracket string begins with
<code class="docutils literal notranslate"><span class="pre">#[FOO[</span></code> and ends with <code class="docutils literal notranslate"><span class="pre">]FOO]</span></code>, where <code class="docutils literal notranslate"><span class="pre">FOO</span></code> is any string not containing
<code class="docutils literal notranslate"><span class="pre">[</span></code> or <code class="docutils literal notranslate"><span class="pre">]</span></code>, including the empty string. (If <code class="docutils literal notranslate"><span class="pre">FOO</span></code> is exactly <code class="docutils literal notranslate"><span class="pre">f</span></code> or
begins with <code class="docutils literal notranslate"><span class="pre">f-</span></code>, the bracket string is interpreted as an <a class="reference internal" href="#syntax-fstrings"><span class="std std-ref">f-string</span></a>.) For example:</p>
<div class="highlight-hylang notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="o">#</span><span class="p">[[</span><span class="s">"That's very kind of yuo [sic]"</span><span class="w"> </span><span class="nv">Tom</span><span class="w"> </span><span class="nv">wrote</span><span class="w"> </span><span class="nv">back.</span><span class="p">]])</span>
<span class="w">  </span><span class="c1">; "That's very kind of yuo [sic]" Tom wrote back.</span>
<span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="o">#</span><span class="p">[</span><span class="nv">==</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="nv">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">=</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="nv">==</span><span class="p">])</span>
<span class="w">  </span><span class="c1">; 1 + 1 = 2</span>
</pre></div>
</div>
<p>Bracket strings are always raw Unicode strings, and don't allow the <code class="docutils literal notranslate"><span class="pre">r</span></code> or
<code class="docutils literal notranslate"><span class="pre">b</span></code> prefixes.</p>
<p>A bracket string can contain newlines, but if it begins with one, the newline
is removed, so you can begin the content of a bracket string on the line
following the opening delimiter with no effect on the content. Any leading
newlines past the first are preserved.</p>
</section>
</section>
<section id="sequential-forms">
<span id="hysequence"></span><h2><a class="toc-backref" href="#id26" role="doc-backlink">Sequential forms</a><a class="headerlink" href="#sequential-forms" title="Permalink to this heading">&#182;</a></h2>
<p>Sequential forms (<a class="reference internal" href="#hy.models.Sequence" title="hy.models.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>) are nested forms
comprising any number of other forms, in a defined order.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Sequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Sequence" title="Permalink to this definition">&#182;</a></dt>
<dd><p>An abstract base class for sequence-like forms. Sequence models can be operated on
like tuples: you can iterate over them, index into them, and append them with <code class="docutils literal notranslate"><span class="pre">+</span></code>,
but you can't add, remove, or replace elements. Appending a sequence to another
iterable object reuses the class of the left-hand-side object, which is useful when
e.g. you want to concatenate models in a macro.</p>
<p>When you're recursively descending through a tree of models, testing a model with
<code class="docutils literal notranslate"><span class="pre">(isinstance</span> <span class="pre">x</span> <span class="pre">hy.models.Sequence)</span></code> is useful for deciding whether to iterate over
<code class="docutils literal notranslate"><span class="pre">x</span></code>. You can also use the Hyrule function <a class="reference external" href="http://hylang.org/hyrule/doc/v0.7.0/#hyrule.coll?" title="(in Hy)"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">coll?</span></code></a> for this
purpose.</p>
</dd></dl>

<section id="expressions">
<span id="id11"></span><h3><a class="toc-backref" href="#id27" role="doc-backlink">Expressions</a><a class="headerlink" href="#expressions" title="Permalink to this heading">&#182;</a></h3>
<p>Expressions (<a class="reference internal" href="#hy.models.Expression" title="hy.models.Expression"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code></a>) are denoted by
parentheses: <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">&#8230;</span> <span class="pre">)</span></code>. The compiler evaluates expressions by checking the
first element, called the head.</p>
<ul class="simple">
<li><p>If the head is a symbol, and the symbol is the name of a currently defined
macro, the macro is called.</p>
<ul>
<li><p>Exception: if the symbol is also the name of a function in
<a class="reference internal" href="/hy/doc/v1.0.0/api#module-hy.pyops" title="hy.pyops"><code class="xref hy hy-mod docutils literal notranslate"><span class="pre">hy.pyops</span></code></a>, and one of the arguments is an
<a class="reference internal" href="/hy/doc/v1.0.0/api#unpack-iterable" title="unpack-iterable"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">unpack-iterable</span></code></a> form, the <code class="docutils literal notranslate"><span class="pre">pyops</span></code> function is called instead
of the macro. This makes reasonable-looking expressions work that would
otherwise fail. For example, <code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">#*</span> <span class="pre">summands)</span></code> is understood as
<code class="docutils literal notranslate"><span class="pre">(hy.pyops.+</span> <span class="pre">#*</span> <span class="pre">summands)</span></code>, because Python provides no way to sum a list
of unknown length with a real addition expression.</p></li>
</ul>
</li>
<li><p>If the head is itself an expression of the form <code class="docutils literal notranslate"><span class="pre">(.</span> <span class="pre">None</span> <span class="pre">&#8230;)</span></code> (typically
produced with a <a class="reference internal" href="#dotted-identifiers"><span class="std std-ref">dotted identifier</span></a> like <code class="docutils literal notranslate"><span class="pre">.add</span></code>),
it's used to construct a method call with the element after <code class="docutils literal notranslate"><span class="pre">None</span></code> as the
object: thus, <code class="docutils literal notranslate"><span class="pre">(.add</span> <span class="pre">my-set</span> <span class="pre">5)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">((.</span> <span class="pre">my-set</span> <span class="pre">add)</span> <span class="pre">5)</span></code>,
which becomes <code class="docutils literal notranslate"><span class="pre">my_set.add(5)</span></code> in Python.</p>
<ul id="hy-r">
<li><p>Exception: expressions like <code class="docutils literal notranslate"><span class="pre">((.</span> <span class="pre">hy</span> <span class="pre">R</span> <span class="pre">module-name</span> <span class="pre">macro-name)</span> <span class="pre">&#8230;)</span></code>, or equivalently <code class="docutils literal notranslate"><span class="pre">(hy.R.module-name.macro-name</span> <span class="pre">&#8230;)</span></code>, get special treatment. They <a class="reference internal" href="/hy/doc/v1.0.0/api#require" title="require"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">require</span></code></a> the module <code class="docutils literal notranslate"><span class="pre">module-name</span></code> and call its macro <code class="docutils literal notranslate"><span class="pre">macro-name</span></code>, so <code class="docutils literal notranslate"><span class="pre">(hy.R.foo.bar</span> <span class="pre">1)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(require</span> <span class="pre">foo)</span> <span class="pre">(foo.bar</span> <span class="pre">1)</span></code>, but without bringing <code class="docutils literal notranslate"><span class="pre">foo</span></code> or <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> into scope. Thus <code class="docutils literal notranslate"><span class="pre">hy.R</span></code> is convenient syntactic sugar for macros you'll only call once in a file, or for macros that you want to appear in the expansion of other macros without having to call <a class="reference internal" href="/hy/doc/v1.0.0/api#require" title="require"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">require</span></code></a> in the expansion. As with <a class="reference internal" href="/hy/doc/v1.0.0/api#hy.I" title="hy.I"><code class="xref hy hy-class docutils literal notranslate"><span class="pre">hy.I</span></code></a>, dots in the module name must be replaced with slashes.</p></li>
</ul>
</li>
<li><p>Otherwise, the expression is compiled into a Python-level call, with the
head being the calling object. (So, you can call a function that has
the same name as a macro with an expression like <code class="docutils literal notranslate"><span class="pre">((do</span> <span class="pre">setv)</span> <span class="pre">&#8230;)</span></code>.) The
remaining forms are understood as arguments. Use <a class="reference internal" href="/hy/doc/v1.0.0/api#unpack-iterable" title="unpack-iterable"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">unpack-iterable</span></code></a>
or <a class="reference internal" href="/hy/doc/v1.0.0/api#unpack-mapping" title="unpack-mapping"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">unpack-mapping</span></code></a> to break up data structures into individual
arguments at runtime.</p></li>
</ul>
<p>The empty expression <code class="docutils literal notranslate"><span class="pre">()</span></code> is legal at the reader level, but has no inherent
meaning. Trying to compile it is an error. For the empty tuple, use <code class="docutils literal notranslate"><span class="pre">#()</span></code>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Expression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Expression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Expression" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a parenthesized Hy expression.</p>
</dd></dl>

</section>
<section id="list-tuple-and-set-literals">
<span id="hylist"></span><h3><a class="toc-backref" href="#id28" role="doc-backlink">List, tuple, and set literals</a><a class="headerlink" href="#list-tuple-and-set-literals" title="Permalink to this heading">&#182;</a></h3>
<ul class="simple">
<li><p>Literal <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>s (<a class="reference internal" href="#hy.models.List" title="hy.models.List"><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code></a>) are denoted by <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">&#8230;</span>
<span class="pre">]</span></code>.</p></li>
<li><p>Literal <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>s (<a class="reference internal" href="#hy.models.Tuple" title="hy.models.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code></a>) are denoted by
<code class="docutils literal notranslate"><span class="pre">#(</span> <span class="pre">&#8230;</span> <span class="pre">)</span></code>.</p></li>
<li><p>Literal <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#set" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>s (<a class="reference internal" href="#hy.models.Set" title="hy.models.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a>) are denoted by <code class="docutils literal notranslate"><span class="pre">#{</span> <span class="pre">&#8230;</span>
<span class="pre">}</span></code>.</p></li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.List">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">List</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.List" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>.</p>
<p>Many macros use this model type specially, for something other than defining a
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>. For example, <a class="reference internal" href="/hy/doc/v1.0.0/api#defn" title="defn"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">defn</span></code></a> expects its function parameters as a
square-bracket-delimited list, and <a class="reference internal" href="/hy/doc/v1.0.0/api#for" title="for"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">for</span></code></a> expects a list of iteration
clauses.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Tuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Tuple" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Set">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Set" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#set" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>. Unlike actual sets, the model retains duplicates
and the order of elements.</p>
</dd></dl>

</section>
<section id="dictionary-literals">
<span id="dict-literals"></span><h3><a class="toc-backref" href="#id29" role="doc-backlink">Dictionary literals</a><a class="headerlink" href="#dictionary-literals" title="Permalink to this heading">&#182;</a></h3>
<p>Literal dictionaries (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#hy.models.Dict" title="hy.models.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a>) are
denoted by <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">&#8230;</span> <span class="pre">}</span></code>. Even-numbered child forms (counting the first as 0)
become the keys whereas odd-numbered child forms become the values. For
example, <code class="docutils literal notranslate"><span class="pre">{"a"</span> <span class="pre">1</span> <span class="pre">"b"</span> <span class="pre">2}</span></code> produces a dictionary mapping <code class="docutils literal notranslate"><span class="pre">"a"</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code> and
<code class="docutils literal notranslate"><span class="pre">"b"</span></code> to <code class="docutils literal notranslate"><span class="pre">2</span></code>. Trying to compile a <a class="reference internal" href="#hy.models.Dict" title="hy.models.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a> with an
odd number of child models is an error.</p>
<p>As in Python, calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> with keyword arguments is often more
convenient than using a literal dictionary.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.Dict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">Dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.Dict" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a literal <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. <code class="docutils literal notranslate"><span class="pre">keys</span></code>, <code class="docutils literal notranslate"><span class="pre">values</span></code>, and <code class="docutils literal notranslate"><span class="pre">items</span></code> methods are
provided, each returning a list, although this model type does none of the
normalization of a real <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. In the case of an odd number of child models,
<code class="docutils literal notranslate"><span class="pre">keys</span></code> returns the last child whereas <code class="docutils literal notranslate"><span class="pre">values</span></code> and <code class="docutils literal notranslate"><span class="pre">items</span></code> ignore it.</p>
</dd></dl>

</section>
<section id="format-strings">
<span id="syntax-fstrings"></span><h3><a class="toc-backref" href="#id30" role="doc-backlink">Format strings</a><a class="headerlink" href="#format-strings" title="Permalink to this heading">&#182;</a></h3>
<p>A format string (or "f-string", or "formatted string literal") is a string
literal with embedded code, possibly accompanied by formatting commands. The
result is an <a class="reference internal" href="#hy.models.FString" title="hy.models.FString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FString</span></code></a>, Hy f-strings work much like
<a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings" title="(in Python v3.12)"><span class="xref std std-ref">Python f-strings</span></a> except that the embedded code is in Hy
rather than Python.</p>
<div class="highlight-hylang notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="nv">f</span><span class="s">"The sum is {(+ 1 1)}."</span><span class="p">)</span><span class="w">  </span><span class="c1">; =&gt; The sum is 2.</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code>, and <code class="docutils literal notranslate"><span class="pre">:</span></code> are identifier characters in Hy, Hy decides where
the code in a replacement field ends (and any debugging <code class="docutils literal notranslate"><span class="pre">=</span></code>, conversion
specifier, or format specifier begins) by parsing exactly one form. You can use
<code class="docutils literal notranslate"><span class="pre">do</span></code> to combine several forms into one, as usual. Whitespace may be necessary
to terminate the form:</p>
<div class="highlight-hylang notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">setv </span><span class="nv">foo</span><span class="w"> </span><span class="s">"a"</span><span class="p">)</span>
<span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="nv">f</span><span class="s">"{foo:x&lt;5}"</span><span class="p">)</span><span class="w">   </span><span class="c1">; =&gt; NameError: name 'hyx_fooXcolonXxXlessHthan_signX5' is not defined</span>
<span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="nv">f</span><span class="s">"{foo :x&lt;5}"</span><span class="p">)</span><span class="w">  </span><span class="c1">; =&gt; axxxx</span>
</pre></div>
</div>
<p>Unlike Python, whitespace is allowed between a conversion and a format
specifier.</p>
<p>Also unlike Python, comments and backslashes are allowed in replacement fields.
The same reader is used for the form to be evaluated as for elsewhere in the
language. Thus e.g. <code class="docutils literal notranslate"><span class="pre">f"{"a"}"</span></code> is legal, and equivalent to <code class="docutils literal notranslate"><span class="pre">"a"</span></code>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hy.models.FString">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">FString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">brackets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.FString" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Represents a format string as an iterable collection of <a class="reference internal" href="#hy.models.String" title="hy.models.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">hy.models.String</span></code></a>
and <a class="reference internal" href="#hy.models.FComponent" title="hy.models.FComponent"><code class="xref py py-class docutils literal notranslate"><span class="pre">hy.models.FComponent</span></code></a>. The design mimics <a class="reference external" href="https://docs.python.org/3/library/ast.html#ast.JoinedStr" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.JoinedStr</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>brackets</strong> -- As in <a class="reference internal" href="#hy.models.String" title="hy.models.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">hy.models.String</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hy.models.FComponent">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hy.models.</span></span><span class="sig-name descname"><span class="pre">FComponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conversion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hy.models.FComponent" title="Permalink to this definition">&#182;</a></dt>
<dd><p>An analog of <a class="reference external" href="https://docs.python.org/3/library/ast.html#ast.FormattedValue" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.FormattedValue</span></code></a>. The first node in the contained sequence
is the value being formatted. The rest of the sequence contains the nodes in the
format spec (if any).</p>
</dd></dl>

</section>
</section>
<section id="additional-sugar">
<span id="more-sugar"></span><h2><a class="toc-backref" href="#id31" role="doc-backlink">Additional sugar</a><a class="headerlink" href="#additional-sugar" title="Permalink to this heading">&#182;</a></h2>
<p>Syntactic sugar is available to construct two-item <a class="reference internal" href="#expressions"><span class="std std-ref">expressions</span></a> with certain heads. When the sugary characters are encountered
by the reader, a new expression is created with the corresponding macro name as
the first element and the next parsed form as the second. No parentheses are
required. Thus, since <code class="docutils literal notranslate"><span class="pre">'</span></code> is short for <code class="docutils literal notranslate"><span class="pre">quote</span></code>, <code class="docutils literal notranslate"><span class="pre">'FORM</span></code> is read as
<code class="docutils literal notranslate"><span class="pre">(quote</span> <span class="pre">FORM)</span></code>. Whitespace is allowed, as in <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">FORM</span></code>. This is all resolved
at the reader level, so the model that gets produced is the same whether you
take your code with sugar or without.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Macro</p></th>
<th class="head"><p>Syntax</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="/hy/doc/v1.0.0/api#quote" title="quote"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">quote</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'FORM</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="/hy/doc/v1.0.0/api#quasiquote" title="quasiquote"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">quasiquote</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">`FORM</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="/hy/doc/v1.0.0/api#unquote" title="unquote"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">unquote</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">~FORM</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="/hy/doc/v1.0.0/api#unquote-splice" title="unquote-splice"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">unquote-splice</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">~@FORM</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="/hy/doc/v1.0.0/api#unpack-iterable" title="unpack-iterable"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">unpack-iterable</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#*</span> <span class="pre">FORM</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="/hy/doc/v1.0.0/api#unpack-mapping" title="unpack-mapping"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">unpack-mapping</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#**</span> <span class="pre">FORM</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="reader-macros">
<h2><a class="toc-backref" href="#id32" role="doc-backlink">Reader macros</a><a class="headerlink" href="#reader-macros" title="Permalink to this heading">&#182;</a></h2>
<p>A hash (<code class="docutils literal notranslate"><span class="pre">#</span></code>) followed by a <a class="reference internal" href="#symbols"><span class="std std-ref">symbol</span></a> invokes the <a class="reference internal" href="/hy/doc/v1.0.0/macros#reader-macros"><span class="std std-ref">reader
macro</span></a> named by the symbol. (Trying to call an undefined reader
macro is a syntax error.) Parsing of the remaining source code is under control
of the reader macro until it returns.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2024 the authors.
    </div>
  </body>
</html>